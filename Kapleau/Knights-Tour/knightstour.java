/*
Knight's Tour
Marek Kowalik
CS 280 - 141
31010270

Using Warnsdorff's rule and my take on Ira Pohl's tie-breaking method.
This solution is implemented recursively.

Use: java knightstour 2 3
java knightstour [row start] [column start]

*/

import java.util.*;

public class knightstour
{
    // First move and the initial position of the knight before the tour starts
    static String firstMove;
    // ArrayList containing the possible next moves generated by peekMove().
    static ArrayList<String> possibleNextMoves = new ArrayList<String>();
    // ArrayList containing all the moves made in order.
    static ArrayList<String> movesMade = new ArrayList<String>();

    static int[][] output = new int[8][8];
    
    // Method that propogates an ArrayList(possibleNextMoves) with all the possible moves
    // the knight can take from the given chessboard place. The places on the board written to the
    // ArrayList(possibleNextMoves) are the ones that have not been visited before yet or
    // the current place being analyzed.
    public static void peekMove(String move)
    {
	String possibleMove;
	
	int newRow;
	int newColumn;

	int row = Character.getNumericValue(move.charAt(0));
	int column = Character.getNumericValue(move.charAt(1));

	if ( (row > 0) && (column < 6) )
	    {
		newRow = row - 1;
		newColumn = column + 2;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row > 0) && (column > 1) && (column < 8) )
	    {
		newRow = row - 1;
		newColumn = column - 2;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row < 7) && (column < 6) )
	    {
		newRow = row + 1;
		newColumn = column + 2;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row < 7) && (column > 2) && (column < 8) )
	    {
		newRow = row + 1;
		newColumn = column - 2;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row > 1) && (column < 7) )
	    {
		newRow = row - 2;
		newColumn = column + 1;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row > 1) && (column > 0) && (column < 8) )
	    {
		newRow = row - 2;
		newColumn = column - 1;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row < 6) && (column < 7) )
	    {
		newRow = row + 2;
		newColumn = column + 1;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
	if ( (row < 6) && (column > 0) && (column < 8) )
	    {
		newRow = row + 2;
		newColumn = column - 1;
		String possibleRow = Integer.toString(newRow);
		String possibleColumn = Integer.toString(newColumn);
		possibleMove = possibleRow + possibleColumn;
		if ( movesMade.contains(possibleMove) )
		    {
			//System.out.println(possibleMove + " is currently in movesMade.");
		    }
		else
		    {
			possibleNextMoves.add(possibleMove);
			//System.out.println(possibleMove + " is not in movesMade.");
		    }
	    }
    }

    public static String deeperPeek()
    {
	int possibleMovesSize = possibleNextMoves.size();
	
	String returnStr;
	
	String deepPeekMoves[];
	deepPeekMoves = new String[possibleMovesSize];

	int deepPeekMovesCount[];
	deepPeekMovesCount = new int[possibleMovesSize];
	
	for (int i = 0; i < possibleMovesSize; i++)
	    {
		deepPeekMoves[i] = possibleNextMoves.get(i);
		//System.out.println(deepPeekMoves[i]);
	    }
	for (int m = 0; m < possibleMovesSize; m++)
	    {
		possibleNextMoves.clear();
		movesMade.add(deepPeekMoves[m]);
		peekMove(deepPeekMoves[m]);
		deepPeekMovesCount[m] = possibleNextMoves.size();
		//System.out.println(deepPeekMovesCount[m] + " | " + deepPeekMoves[m]);
		movesMade.remove(deepPeekMoves[m]);
	    }
	//System.out.println("--------------------");
	// Sorts the vector in ascending order to see if there is a tie between which
	// spot has the lowest potential amount of moves.
	if ( deepPeekMoves.length > 1 )
	    {
		int a;
		int b;
		int movesCount;
	        String move;

		for (a = 1; a < deepPeekMovesCount.length; a++)
		    {
			movesCount = deepPeekMovesCount[a];
			move = deepPeekMoves[a];
			for (b = a - 1; (b >= 0) && (deepPeekMovesCount[b] > movesCount); b--)
			    {
				deepPeekMovesCount[b+1] = deepPeekMovesCount[b];
				deepPeekMoves[b+1] = deepPeekMoves[b];
			    }
			deepPeekMovesCount[b+1] = movesCount;
			deepPeekMoves[b+1] = move;
		    }
		int low = deepPeekMovesCount[0];
		int lowCount = 0;
		
		String deepPeekTies[];
		deepPeekTies = new String[possibleMovesSize];

		int deepPeekTiesCount[];
		deepPeekTiesCount = new int[possibleMovesSize];
		
		for (int z = 0; z < deepPeekMovesCount.length; z++)
		    {
			if ( deepPeekMovesCount[z] == low )
			    {
				deepPeekTiesCount[lowCount] = deepPeekMovesCount[z];
				deepPeekTies[lowCount] = deepPeekMoves[z];
				lowCount++;
			    }
		    }
		returnStr = deepPeekTies[0];
		//System.out.println(deepPeekTies[1]);
		return returnStr;
	    }
	else
	    {
		returnStr =  deepPeekMoves[0];
		return returnStr;
	    }
    }

    public static void tour(int moves)
    {
	if ( moves < 1)
	    {
		movesMade.add(firstMove);
		peekMove(firstMove);
		String secondMove = deeperPeek();
		movesMade.add(secondMove);
		moves++;
		moves++;
		tour(moves);
	    }
	else
	    {
		if ( (moves > 1) && (moves < 64) )
		    {
			possibleNextMoves.clear();
			peekMove(movesMade.get(moves-1));
			String nextMove = deeperPeek();
			movesMade.add(nextMove);
			moves++;
			tour(moves);
		    }
		//System.out.println("First two moves have been made.");
	    }
    }

    public static void createOutput()
    {
	String move;
	int row;
	int column;
	for (int i = 0; i < 64; i++)
	    {
		move = movesMade.get(i);
		row = Character.getNumericValue(move.charAt(0));
		column = Character.getNumericValue(move.charAt(1));
		output[row][column] = i + 1;
	    }
	for (int b = 0; b < 8; b++)
	    {
		for (int a = 0; a < 8; a++)
		    {
			if ( output[b][a] < 10 )
			    {
				System.out.print(" " + output[b][a] + "  ");
			    }
			else
			    {
				System.out.print(output[b][a] + "  ");
			    }
		    }
		System.out.println();
	    }
    }
    
    public static void main(String[] Args)
    {
	if ( Args.length != 2 )
	    {
		System.out.println("Use: java knightstour 2 3");
		return;
	    }
	firstMove = Args[0] + Args[1];

	int moves = 0;
	tour(moves);

	//peekMove(firstMove);
	//deeperPeek();
	//System.out.println(possibleNextMoves);
	//System.out.println(deeperPeek());
	System.out.println(movesMade.size() + " moves made.");
	createOutput();
	/*for (int i = 0; i < movesMade.size(); i++)
	    {
		System.out.println(movesMade.get(i));
		}*/
	return;
    }
}
