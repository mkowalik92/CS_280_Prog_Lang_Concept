/*
Knight's Tour
Marek Kowalik
CS 280 - 141
31010270

Using Warnsdorff's rule and my take on Ira Pohl's tie-breaking method.
This solution is implemented recursively.

Use: ./knightstour 2 3
./knightstour [row start] [column start]

*/

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

/*
All possible moves for any square. Doesn't mean it can move in that direction.
-2 -1 | -1 -2 | +1 -2 | +2 -1
-2 +1 | -1 +2 | +1 +2 | +2 +1
*/

// All moves made in order.
std::vector<std::string> movesMade;

// Possible next moves generated by peekMove()
std::vector<std::string> possibleNextMoves;

// Vector table containing the amount of possible moves for each move generated
// by peekMove(). This is populated by the deeperPeek() function.
std::vector<std::vector<std::string>> deeperPeekMovesStr;

// Contains all the ties of possible moves from the deeperPeekMovesStr multi-dimensional
// vector
std::vector<std::string> deepPeekTies;

// First move on the chessboard. Where the initial knight is placed and/or the used command
// line argument when starting the program
std::string firstMove;

// This is the array that holds the intended output which when printed is a visual map of the moves
// made by the knight on the chessboard
int output [8][8];

// struct that helps with the sorting of only the first column of the multi-dimensional vector
// deepPeekMovesStr
struct FirstColumnOnlyCmp
{
  bool operator()(const std::vector<std::string>& lhs,
		  const std::vector<std::string>& rhs) const
  {
    return lhs[0] < rhs[0];
  }
};

// Function for converting character variables to integer variables
int char_to_int(char c)
{
  return static_cast<int>(c - '0');
}

void createOutput()
{
  std::string move;
  int row;
  int column;
  for ( int i = 0; i < 64; i++ )
    {
      move = movesMade[i];
      row = char_to_int(move[0]);
      column = char_to_int(move[1]);
      //std::cout << row << column << std::endl;
      output[row][column] = i + 1;
      //std::cout << output[row][column] << " | " << row << column << std::endl;
    }
  for ( int b = 0; b < 8; b++ )
    {
      for ( int a = 0; a < 8; a++ )
	{
	  if ( output[b][a] < 10 )
	    {
	      std::cout << " " << output[b][a] << "  ";
	    }
	  else
	    {
	      std::cout << output[b][a] << "  ";
	    }
	}
      std::cout << std::endl;
    }
}

// peekMove(string str)
// This function makes a vector of all the possible moves the knight can take from the
// given chessboard place. The places on the board written to the vector possibleNextMoves
// are ones that have not been visited before yet or the current piece being analyzed.
void peekMove(std::string move)
{
  std::string possibleMove;
  
  int newRow;
  int newColumn;

  int row = char_to_int(move[0]);
  int column = char_to_int(move[1]);

  if ( (row > 0) && (column < 6) )
    {
      newRow = row - 1;
      newColumn = column + 2;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row > 0) && (column > 1) && (column < 8) )
    {
      newRow = row - 1;
      newColumn = column - 2;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row < 7) && (column < 6) )
    {
      newRow = row + 1;
      newColumn = column + 2;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row < 7) && (column > 1) && (column < 8) )
    {
      newRow = row + 1;
      newColumn = column - 2;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row > 1) && (column < 7) )
    {
      newRow = row - 2;
      newColumn = column + 1;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row > 1) && (column > 0) && (column < 8) )
    {
      newRow = row - 2;
      newColumn = column - 1;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row < 6) && (column < 7) )
    {
      newRow = row + 2;
      newColumn = column + 1;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
  if ( (row < 6) && (column > 0) && (column < 8) )
    {
      newRow = row + 2;
      newColumn = column - 1;
      std::string possibleRow = std::to_string(newRow);
      std::string possibleColumn = std::to_string(newColumn);
      possibleMove = possibleRow + possibleColumn;
      if ( std::find(movesMade.begin(), movesMade.end(), possibleMove) != movesMade.end())
	{
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
      else
	{
	  possibleNextMoves.push_back(possibleMove);
	  possibleRow.clear();
	  possibleColumn.clear();
	  possibleMove.clear();
	}
    }
}

// Peeks into data retrieved by peekMove to see how many potential moves each of
// those squares would have. If there is a tie it settles the tie. Then returns a
// string with the value of the next suggested move.
std::string deeperPeek()
{
  int possibleMovesSize = possibleNextMoves.size();
  std::string returnStr;

  //Resize multi-dimensional vector so it is as follows:
  // vector = { {movesAvailableAt,thisMove},{}, .... }
  deeperPeekMovesStr.resize(possibleMovesSize);
  for (int v = 0; v < possibleMovesSize; v++)
    {
      deeperPeekMovesStr[v].resize(2);
    }
  
  for (int i = 0; i < possibleMovesSize; i++)
    {
      // Assigns the possible move to the second column so the amount of moves and the
      // possible move made are at the same place(?).
      deeperPeekMovesStr[i][1] = possibleNextMoves[i];	
    }
  for (int m = 0; m < possibleMovesSize; m++)
    {
      // Find and assign to the array the amount of moves each of those squares would be able to make
      possibleNextMoves.clear();
      std::string futureMoveStr = deeperPeekMovesStr[m][1];
      movesMade.push_back(futureMoveStr);
      peekMove(futureMoveStr);
      deeperPeekMovesStr[m][0] = std::to_string(possibleNextMoves.size());
      movesMade.pop_back();
    }

  if ( deeperPeekMovesStr.size() > 1 )
    {
      // Sorts the vector in ascending order to see if there is a tie between which
      // spot has the lowest potential amount of moves.
      std::sort(deeperPeekMovesStr.begin(), deeperPeekMovesStr.end(), FirstColumnOnlyCmp());
      // return next suggested move after randomly(?) selecting tie winner if there is
      // another after the first peek
      int low = std::stoi(deeperPeekMovesStr[0][0]);
      for (int z = 0; z < deeperPeekMovesStr.size(); z++)
	{
	  if ( std::stoi(deeperPeekMovesStr[z][0]) == low )
	    {
	      deepPeekTies.push_back(deeperPeekMovesStr[z][1]);
	    }
	}
      returnStr = deepPeekTies[0];
      return returnStr;
    }
  else
    {
      returnStr = deeperPeekMovesStr[0][1];
      return returnStr;
      //return next suggested move if there is only one move that can be made
    }
}

void tour(int moves)
{
  if ( moves < 1 )
    {
      // Adds the initial knight position to vector of overal moves made.
      movesMade.push_back(firstMove);
      peekMove(firstMove);
      std::string secondMove = deeperPeek();
      movesMade.push_back(secondMove);
      moves++;
      moves++;
      tour(moves);
    }
  else
    {
      if ( (moves > 1) && (moves < 64) )
	{
	  possibleNextMoves.clear();
	  deeperPeekMovesStr.clear();
	  deepPeekTies.clear();
	  peekMove(movesMade[moves-1]);
	  std::string nextMove = deeperPeek();
	  movesMade.push_back(nextMove);
	  moves++;
	  /*
	  if ( moves == 64)
	    {
	      std::cout << moves << " moves made" << std::endl;
	    }
	  */
	  tour(moves);
	}
    }
}

int main(int argc, char* argv[])
{
  //Check to see if there is the appropriate amount of arguments
  if ( argc < 3 )
    {
      std::cout << "Use: ./knightstour 2 3" << std::endl;
      return 0;
    }
  //Convert the character pointer arguments that define
  // the first move into a string type for easy use
  std::string firstMove0(argv[1]);
  std::string firstMove1(argv[2]);
  firstMove = firstMove0 + firstMove1;

  int moves = 0;

  tour(moves);
  createOutput();
  /*
  for (std::vector<std::string>::const_iterator i = movesMade.begin(); i != movesMade.end(); ++i)
    {
      std::cout << *i << " ";
    }
  std::cout << std::endl;
  */
  return 0;
}
